name: Render Monitor (Heartbeat + Hourly Stats)

on:
  workflow_dispatch:
  schedule:
    - cron: "*/5 * * * *"

permissions:
  contents: read

concurrency:
  group: render-monitor
  cancel-in-progress: true

jobs:
  monitor:
    runs-on: ubuntu-latest
    steps:
      - name: Restore state (cache)
        uses: actions/cache@v4
        with:
          path: .ping_state
          key: render-monitor-state
          restore-keys: render-monitor-state

      - name: Ensure state dir
        shell: bash
        run: mkdir -p .ping_state

      - name: Ping Render (collect metrics)
        id: ping
        shell: bash
        run: |
          set -euo pipefail

          URL="https://void-seven-api.onrender.com/health"

          OUT="$(curl -sS -o /dev/null \
            -w "%{http_code} %{time_total}" \
            --connect-timeout 10 \
            --max-time 30 \
            "$URL" || true)"

          CODE="$(echo "$OUT" | awk '{print $1}')"
          TIME_S="$(echo "$OUT" | awk '{print $2}')"

          [[ -z "${CODE:-}" ]] && CODE="000"
          [[ -z "${TIME_S:-}" ]] && TIME_S="0"

          TIME_MS="$(awk -v t="$TIME_S" 'BEGIN{printf("%d", t*1000)}')"

          STATE="down"
          if [[ "$CODE" =~ ^2[0-9][0-9]$ ]]; then
            STATE="up"
          fi

          echo "code=$CODE" >> "$GITHUB_OUTPUT"
          echo "time_ms=$TIME_MS" >> "$GITHUB_OUTPUT"
          echo "url=$URL" >> "$GITHUB_OUTPUT"
          echo "state=$STATE" >> "$GITHUB_OUTPUT"

      - name: Update rolling stats (since last hourly)
        id: stats
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p .ping_state

          SUCCESS=0
          ERROR=0
          SUM_MS=0
          MAX_MS=0
          COUNT=0

          [[ -f .ping_state/success.txt ]] && SUCCESS="$(cat .ping_state/success.txt)"
          [[ -f .ping_state/error.txt ]] && ERROR="$(cat .ping_state/error.txt)"
          [[ -f .ping_state/sum_ms.txt ]] && SUM_MS="$(cat .ping_state/sum_ms.txt)"
          [[ -f .ping_state/max_ms.txt ]] && MAX_MS="$(cat .ping_state/max_ms.txt)"
          [[ -f .ping_state/count.txt ]] && COUNT="$(cat .ping_state/count.txt)"

          MS="${{ steps.ping.outputs.time_ms }}"

          # increment counters
          COUNT=$((COUNT + 1))
          SUM_MS=$((SUM_MS + MS))

          if [[ "$MS" -gt "$MAX_MS" ]]; then
            MAX_MS="$MS"
          fi

          if [[ "${{ steps.ping.outputs.state }}" == "up" ]]; then
            SUCCESS=$((SUCCESS + 1))
          else
            ERROR=$((ERROR + 1))
          fi

          # persist
          echo "$SUCCESS" > .ping_state/success.txt
          echo "$ERROR" > .ping_state/error.txt
          echo "$SUM_MS" > .ping_state/sum_ms.txt
          echo "$MAX_MS" > .ping_state/max_ms.txt
          echo "$COUNT" > .ping_state/count.txt

          # outputs (optional)
          echo "success=$SUCCESS" >> "$GITHUB_OUTPUT"
          echo "error=$ERROR" >> "$GITHUB_OUTPUT"
          echo "sum_ms=$SUM_MS" >> "$GITHUB_OUTPUT"
          echo "max_ms=$MAX_MS" >> "$GITHUB_OUTPUT"
          echo "count=$COUNT" >> "$GITHUB_OUTPUT"

      # --------------------
      # HEARTBEAT (EVERY RUN)
      # --------------------
      - name: Discord Heartbeat
        shell: bash
        run: |
          NOW="$(TZ=Europe/Berlin date '+%H:%M')"
          ICON="ğŸ”´"
          if [[ "${{ steps.ping.outputs.state }}" == "up" ]]; then
            ICON="ğŸŸ¢"
          fi

          curl -H "Content-Type: application/json" \
            -d "{\"content\":\"ğŸ’“ HEARTBEAT | ${NOW} ${ICON}\nStatus: ${{ steps.ping.outputs.code }} | Zeit: ${{ steps.ping.outputs.time_ms }}ms\nURL: ${{ steps.ping.outputs.url }}\"}" \
            "${{ secrets.DISCORD_WEBHOOK }}"

      # --------------------
      # HOURLY PING (EVERY 60 MIN, WITH STATS)
      # --------------------
      - name: Discord Hourly Ping (every 60 min)
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p .ping_state

          NOW_TS="$(date +%s)"
          LAST_TS="0"
          [[ -f .ping_state/last_hourly_ts.txt ]] && LAST_TS="$(cat .ping_state/last_hourly_ts.txt)"

          DIFF=$((NOW_TS - LAST_TS))
          if [[ "$DIFF" -lt 3600 ]]; then
            exit 0
          fi

          SUCCESS="$(cat .ping_state/success.txt 2>/dev/null || echo 0)"
          ERROR="$(cat .ping_state/error.txt 2>/dev/null || echo 0)"
          SUM_MS="$(cat .ping_state/sum_ms.txt 2>/dev/null || echo 0)"
          MAX_MS="$(cat .ping_state/max_ms.txt 2>/dev/null || echo 0)"
          COUNT="$(cat .ping_state/count.txt 2>/dev/null || echo 0)"

          AVG_MS="0"
          if [[ "$COUNT" -gt 0 ]]; then
            AVG_MS=$((SUM_MS / COUNT))
          fi

          NOW_HUMAN="$(TZ=Europe/Berlin date '+%Y-%m-%d %H:%M %Z')"

          ICON="ğŸ”´"
          if [[ "${{ steps.ping.outputs.state }}" == "up" ]]; then
            ICON="ğŸŸ¢"
          fi

          curl -H "Content-Type: application/json" \
            -d "{\"content\":\"${ICON} HOURLY PING | ${NOW_HUMAN}\nâœ… Success: ${SUCCESS}\nâŒ Errors: ${ERROR}\nâ± Avg: ${AVG_MS}ms | Max: ${MAX_MS}ms\nLast: ${{ steps.ping.outputs.code }} | ${{ steps.ping.outputs.time_ms }}ms\nURL: ${{ steps.ping.outputs.url }}\"}" \
            "${{ secrets.DISCORD_WEBHOOK }}"

          # reset stats window
          echo 0 > .ping_state/success.txt
          echo 0 > .ping_state/error.txt
          echo 0 > .ping_state/sum_ms.txt
          echo 0 > .ping_state/max_ms.txt
          echo 0 > .ping_state/count.txt

          # store last hourly ts
          echo "$NOW_TS" > .ping_state/last_hourly_ts.txt
